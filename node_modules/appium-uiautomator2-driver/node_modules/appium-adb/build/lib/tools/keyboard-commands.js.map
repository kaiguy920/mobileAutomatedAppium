{"version":3,"file":"keyboard-commands.js","names":["KEYCODE_ESC","KEYCODE_BACK","keyboardCommands","hideKeyboard","timeoutMs","isKeyboardShown","canCloseKeyboard","isSoftKeyboardPresent","log","info","keyCode","keyevent","waitForCondition","waitMs","intervalMs","ign","Error","stdout","shell","inputShownMatch","exec","inputViewShownMatch","e","message"],"sources":["../../../lib/tools/keyboard-commands.js"],"sourcesContent":["import log from '../logger.js';\nimport { waitForCondition } from 'asyncbox';\n\nconst KEYCODE_ESC = 111;\nconst KEYCODE_BACK = 4;\n\nconst keyboardCommands = {};\n\n/**\n * Hides software keyboard if it is visible.\n * Noop if the keyboard is already hidden.\n *\n * @param {number} timeoutMs [1000] For how long to wait (in milliseconds)\n * until the keyboard is actually hidden.\n * @returns {boolean} `false` if the keyboard was already hidden\n * @throws {Error} If the keyboard cannot be hidden.\n */\nkeyboardCommands.hideKeyboard = async function hideKeyboard (timeoutMs = 1000) {\n  let {isKeyboardShown, canCloseKeyboard} = await this.isSoftKeyboardPresent();\n  if (!isKeyboardShown) {\n    log.info('Keyboard has no UI; no closing necessary');\n    return false;\n  }\n  // Try ESC then BACK if the first one fails\n  for (const keyCode of [KEYCODE_ESC, KEYCODE_BACK]) {\n    if (canCloseKeyboard) {\n      await this.keyevent(keyCode);\n    }\n    try {\n      return await waitForCondition(async () => {\n        ({isKeyboardShown} = await this.isSoftKeyboardPresent());\n        return !isKeyboardShown;\n      }, {waitMs: timeoutMs, intervalMs: 500});\n    } catch (ign) {}\n  }\n  throw new Error(`The software keyboard cannot be hidden`);\n};\n\n/**\n * @typedef {Object} KeyboardState\n * @property {boolean} isKeyboardShown - Whether soft keyboard is currently visible.\n * @property {boolean} canCloseKeyboard - Whether the keyboard can be closed.\n */\n\n/**\n * Retrieve the state of the software keyboard on the device under test.\n *\n * @return {KeyboardState} The keyboard state.\n */\nkeyboardCommands.isSoftKeyboardPresent = async function isSoftKeyboardPresent () {\n  try {\n    const stdout = await this.shell(['dumpsys', 'input_method']);\n    const inputShownMatch = /mInputShown=(\\w+)/.exec(stdout);\n    const inputViewShownMatch = /mIsInputViewShown=(\\w+)/.exec(stdout);\n    return {\n      isKeyboardShown: !!(inputShownMatch && inputShownMatch[1] === 'true'),\n      canCloseKeyboard: !!(inputViewShownMatch && inputViewShownMatch[1] === 'true'),\n    };\n  } catch (e) {\n    throw new Error(`Error finding softkeyboard. Original error: ${e.message}`);\n  }\n};\n\nexport default keyboardCommands;\n"],"mappings":";;;;;;;;;;;AAAA;;AACA;;AAEA,MAAMA,WAAW,GAAG,GAApB;AACA,MAAMC,YAAY,GAAG,CAArB;AAEA,MAAMC,gBAAgB,GAAG,EAAzB;;AAWAA,gBAAgB,CAACC,YAAjB,GAAgC,eAAeA,YAAf,CAA6BC,SAAS,GAAG,IAAzC,EAA+C;EAC7E,IAAI;IAACC,eAAD;IAAkBC;EAAlB,IAAsC,MAAM,KAAKC,qBAAL,EAAhD;;EACA,IAAI,CAACF,eAAL,EAAsB;IACpBG,eAAA,CAAIC,IAAJ,CAAS,0CAAT;;IACA,OAAO,KAAP;EACD;;EAED,KAAK,MAAMC,OAAX,IAAsB,CAACV,WAAD,EAAcC,YAAd,CAAtB,EAAmD;IACjD,IAAIK,gBAAJ,EAAsB;MACpB,MAAM,KAAKK,QAAL,CAAcD,OAAd,CAAN;IACD;;IACD,IAAI;MACF,OAAO,MAAM,IAAAE,0BAAA,EAAiB,YAAY;QACxC,CAAC;UAACP;QAAD,IAAoB,MAAM,KAAKE,qBAAL,EAA3B;QACA,OAAO,CAACF,eAAR;MACD,CAHY,EAGV;QAACQ,MAAM,EAAET,SAAT;QAAoBU,UAAU,EAAE;MAAhC,CAHU,CAAb;IAID,CALD,CAKE,OAAOC,GAAP,EAAY,CAAE;EACjB;;EACD,MAAM,IAAIC,KAAJ,CAAW,wCAAX,CAAN;AACD,CAnBD;;AAgCAd,gBAAgB,CAACK,qBAAjB,GAAyC,eAAeA,qBAAf,GAAwC;EAC/E,IAAI;IACF,MAAMU,MAAM,GAAG,MAAM,KAAKC,KAAL,CAAW,CAAC,SAAD,EAAY,cAAZ,CAAX,CAArB;IACA,MAAMC,eAAe,GAAG,oBAAoBC,IAApB,CAAyBH,MAAzB,CAAxB;IACA,MAAMI,mBAAmB,GAAG,0BAA0BD,IAA1B,CAA+BH,MAA/B,CAA5B;IACA,OAAO;MACLZ,eAAe,EAAE,CAAC,EAAEc,eAAe,IAAIA,eAAe,CAAC,CAAD,CAAf,KAAuB,MAA5C,CADb;MAELb,gBAAgB,EAAE,CAAC,EAAEe,mBAAmB,IAAIA,mBAAmB,CAAC,CAAD,CAAnB,KAA2B,MAApD;IAFd,CAAP;EAID,CARD,CAQE,OAAOC,CAAP,EAAU;IACV,MAAM,IAAIN,KAAJ,CAAW,+CAA8CM,CAAC,CAACC,OAAQ,EAAnE,CAAN;EACD;AACF,CAZD;;eAcerB,gB"}