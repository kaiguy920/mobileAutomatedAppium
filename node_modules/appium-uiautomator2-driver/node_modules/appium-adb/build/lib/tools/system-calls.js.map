{"version":3,"file":"system-calls.js","names":["systemCallMethods","DEFAULT_ADB_REBOOT_RETRIES","LINKER_WARNING_REGEXP","ADB_RETRY_ERROR_PATTERNS","BINARY_VERSION_PATTERN","BRIDGE_VERSION_PATTERN","CERTS_ROOT","SDK_BINARY_ROOTS","MIN_DELAY_ADB_API_LEVEL","REQUIRED_SERVICES","getSdkBinaryPath","binaryName","getBinaryFromSdkRoot","getBinaryNameForOS","_","memoize","getBinaryNameForOSMemorize","system","isWindows","includes","path","extname","binaries","fullBinaryName","binaryLocs","getSdkBinaryLocationCandidates","sdkRoot","buildToolsDirs","getBuildToolsDirs","buildToolsVersion","filter","x","basename","isEmpty","log","info","push","flatten","map","dir","resolve","binaryLoc","loc","fs","exists","isNull","Error","JSON","stringify","isArray","getAndroidBinaryPath","getSdkRootFromEnv","getBinaryFromPath","which","e","getConnectedDevices","opts","debug","args","executable","defaultArgs","verbose","stdout","exec","message","listHeader","startingIndex","indexOf","slice","excludedLines","allowOfflineDevices","devices","split","trim","line","some","udid","state","description","device","entry","key","value","getDevicesWithRetry","timeoutMs","timer","timing","Timer","start","getDevices","getDuration","asMilliSeconds","toFixed","length","ign","reconnect","restartAdb","sleep","target","adbExec","stderr","suppressKillServer","killServer","error","adbPort","exclusive","resetTelnetAuthToken","homeFolderPath","process","env","platform","warn","dstPath","writeFile","adbExecEmu","cmd","verifyEmulatorConnected","isExecLocked","EXEC_OUTPUT_FORMAT","Object","freeze","STDOUT","FULL","cloneDeep","timeout","adbExecTimeout","DEFAULT_ADB_EXEC_TIMEOUT","timeoutCapName","outputFormat","adbRetried","execFunc","find","arg","test","util","quote","join","replace","errText","p","code","waitForCondition","waitMs","Number","MAX_SAFE_INTEGER","intervalMs","shell","privileged","cmdArr","fullCmd","isRoot","createSubProcess","SubProcess","getAdbPath","getAdbServerPort","getEmulatorPort","emulatorPort","port","getPortFromEmulatorString","emStr","portPattern","parseInt","getConnectedEmulators","emulators","pluralize","setEmulatorPort","emPort","setDeviceId","deviceId","curDeviceId","argsHasDevice","splice","setDevice","deviceObj","getRunningAVD","avdName","emulator","runningAVDName","execEmuConsoleCommand","execTimeout","connTimeout","toLower","getRunningAVDWithRetry","killAllEmulators","killEmulator","hasValue","isEmulatorConnected","launchAVD","language","country","launchTimeout","readyTimeout","retryTimes","emulatorBinaryPath","substr","checkAvdExist","launchArgs","toAvdLocaleArgs","isDelayAdbFeatureEnabled","allowDelayAdb","revision","getEmuVersionInfo","compareVersions","getEmuImageProperties","apiMatch","shellParse","proc","assign","on","Boolean","signal","retry","waitForEmulatorReady","getVersion","result","binaryVersionMatch","binary","version","semver","coerce","build","bridgeVersionMatch","bridge","requiredServicesRe","name","RegExp","services","every","pattern","err","missingServices","zip","waitForDevice","appDeviceReadyTimeout","retries","ping","reboot","wasAlreadyRooted","root","B","delay","setDeviceProperty","unroot","retryInterval","getDeviceProperty","msg","changeUserPrivileges","isElevated","retryIfOffline","cmdFunc","toLowerCase","isSuccessful","fileExists","remotePath","passFlag","checkCmd","ls","lines","l","fileSize","files","match","isNaN","installMitmCertificate","cert","openSsl","getOpenSslForOs","isBuffer","Buffer","from","tmpRoot","tempDir","openDir","srcCert","certHash","dstCertContent","concat","dstCert","rimraf","isMitmCertificateInstalled","tmpCert","posix"],"sources":["../../../lib/tools/system-calls.js"],"sourcesContent":["import path from 'path';\nimport log from '../logger.js';\nimport B from 'bluebird';\nimport { system, fs, util, tempDir, timing } from '@appium/support';\nimport {\n  getBuildToolsDirs, toAvdLocaleArgs,\n  getOpenSslForOs, DEFAULT_ADB_EXEC_TIMEOUT, getSdkRootFromEnv\n} from '../helpers';\nimport { exec, SubProcess } from 'teen_process';\nimport { sleep, retry, retryInterval, waitForCondition } from 'asyncbox';\nimport _ from 'lodash';\nimport semver from 'semver';\n\n\nlet systemCallMethods = {};\n\nconst DEFAULT_ADB_REBOOT_RETRIES = 90;\nconst LINKER_WARNING_REGEXP = /^WARNING: linker.+$/m;\nconst ADB_RETRY_ERROR_PATTERNS = [\n  /protocol fault \\(no status\\)/i,\n  /error: device ('.+' )?not found/i,\n  /error: device still connecting/i,\n];\nconst BINARY_VERSION_PATTERN = /^Version ([\\d.]+)-(\\d+)/m;\nconst BRIDGE_VERSION_PATTERN = /^Android Debug Bridge version ([\\d.]+)/m;\nconst CERTS_ROOT = '/system/etc/security/cacerts';\nconst SDK_BINARY_ROOTS = [\n  'platform-tools',\n  'emulator',\n  ['cmdline-tools', 'latest', 'bin'],\n  'tools',\n  ['tools', 'bin'],\n  '.' // Allow custom sdkRoot to specify full folder path\n];\nconst MIN_DELAY_ADB_API_LEVEL = 28;\nconst REQUIRED_SERVICES = ['activity', 'package', 'mount'];\n\n/**\n * Retrieve full path to the given binary.\n *\n * @param {string} binaryName - The name of the binary.\n * @return {string} Full path to the given binary including current SDK root.\n */\nsystemCallMethods.getSdkBinaryPath = async function getSdkBinaryPath (binaryName) {\n  return await this.getBinaryFromSdkRoot(binaryName);\n};\n\n/**\n * Retrieve full binary name for the current operating system as memotize.\n *\n * @param {string} binaryName - simple binary name, for example 'android'.\n * @return {string} Formatted binary name depending on the current platform,\n *                  for example, 'android.bat' on Windows.\n */\nsystemCallMethods.getBinaryNameForOS = _.memoize(function getBinaryNameForOSMemorize (binaryName) {\n  return getBinaryNameForOS(binaryName);\n});\n\n/**\n * Retrieve full binary name for the current operating system.\n *\n * @param {string} binaryName - simple binary name, for example 'android'.\n * @return {string} Formatted binary name depending on the current platform,\n *                  for example, 'android.bat' on Windows.\n */\nfunction getBinaryNameForOS (binaryName) {\n  if (!system.isWindows()) {\n    return binaryName;\n  }\n\n  if (['android', 'apksigner', 'apkanalyzer'].includes(binaryName)) {\n    return `${binaryName}.bat`;\n  }\n  if (!path.extname(binaryName)) {\n    return `${binaryName}.exe`;\n  }\n  return binaryName;\n}\n\n/**\n * Retrieve full path to the given binary and caches it into `binaries`\n * property of the current ADB instance.\n *\n * @param {string} binaryName - Simple name of a binary file.\n * @return {string} Full path to the given binary. The method tries\n *                  to enumerate all the known locations where the binary\n *                  might be located and stops the search as soon as the first\n *                  match is found on the local file system.\n * @throws {Error} If the binary with given name is not present at any\n *                 of known locations or Android SDK is not installed on the\n *                 local file system.\n */\nsystemCallMethods.getBinaryFromSdkRoot = async function getBinaryFromSdkRoot (binaryName) {\n  if (this.binaries[binaryName]) {\n    return this.binaries[binaryName];\n  }\n  const fullBinaryName = this.getBinaryNameForOS(binaryName);\n  const binaryLocs = getSdkBinaryLocationCandidates(this.sdkRoot, fullBinaryName);\n\n  // get subpaths for currently installed build tool directories\n  let buildToolsDirs = await getBuildToolsDirs(this.sdkRoot);\n  if (this.buildToolsVersion) {\n    buildToolsDirs = buildToolsDirs\n      .filter((x) => path.basename(x) === this.buildToolsVersion);\n    if (_.isEmpty(buildToolsDirs)) {\n      log.info(`Found no build tools whose version matches to '${this.buildToolsVersion}'`);\n    } else {\n      log.info(`Using build tools at '${buildToolsDirs}'`);\n    }\n  }\n  binaryLocs.push(...(_.flatten(buildToolsDirs\n    .map((dir) => [\n      path.resolve(dir, fullBinaryName),\n      path.resolve(dir, 'lib', fullBinaryName),\n    ]))\n  ));\n\n  let binaryLoc = null;\n  for (const loc of binaryLocs) {\n    if (await fs.exists(loc)) {\n      binaryLoc = loc;\n      break;\n    }\n  }\n  if (_.isNull(binaryLoc)) {\n    throw new Error(`Could not find '${fullBinaryName}' in ${JSON.stringify(binaryLocs)}. ` +\n      `Do you have Android Build Tools ${this.buildToolsVersion ? `v ${this.buildToolsVersion} ` : ''}` +\n      `installed at '${this.sdkRoot}'?`);\n  }\n  log.info(`Using '${fullBinaryName}' from '${binaryLoc}'`);\n  this.binaries[binaryName] = binaryLoc;\n  return binaryLoc;\n};\n\n/**\n *  Returns the Android binaries locations\n *\n * @param {string} sdkRoot The path to Android SDK root.\n * @param {string} fullBinaryName The name of full binary name.\n * @return {Array<string>} The list of SDK_BINARY_ROOTS paths\n *                          with sdkRoot and fullBinaryName.\n */\nfunction getSdkBinaryLocationCandidates (sdkRoot, fullBinaryName) {\n  return SDK_BINARY_ROOTS.map((x) =>\n    path.resolve(sdkRoot, ...(_.isArray(x) ? x : [x]), fullBinaryName));\n}\n\n/**\n * Retrieve full path to the given binary.\n * This method does not have cache.\n *\n * @param {string} binaryName - Simple name of a binary file.\n *                              e.g. 'adb', 'android'\n * @return {string} Full path to the given binary. The method tries\n *                  to enumerate all the known locations where the binary\n *                  might be located and stops the search as soon as the first\n *                  match is found on the local file system.\n *                  e.g. '/Path/To/Android/sdk/platform-tools/adb'\n * @throws {Error} If the binary with given name is not present at any\n *                 of known locations or Android SDK is not installed on the\n *                 local file system.\n */\nasync function getAndroidBinaryPath (binaryName) {\n  const fullBinaryName = getBinaryNameForOS(binaryName);\n  const sdkRoot = getSdkRootFromEnv();\n  const binaryLocs = getSdkBinaryLocationCandidates(sdkRoot, fullBinaryName);\n  for (const loc of binaryLocs) {\n    if (await fs.exists(loc)) {\n      return loc;\n    }\n  }\n  throw new Error(`Could not find '${fullBinaryName}' in ${JSON.stringify(binaryLocs)}. ` +\n    `Do you have Android Build Tools installed at '${sdkRoot}'?`);\n}\n\n/**\n * Retrieve full path to a binary file using the standard system lookup tool.\n *\n * @param {string} binaryName - The name of the binary.\n * @return {string} Full path to the binary received from 'which'/'where'\n *                  output.\n * @throws {Error} If lookup tool returns non-zero return code.\n */\nsystemCallMethods.getBinaryFromPath = async function getBinaryFromPath (binaryName) {\n  if (this.binaries[binaryName]) {\n    return this.binaries[binaryName];\n  }\n\n  const fullBinaryName = this.getBinaryNameForOS(binaryName);\n  try {\n    const binaryLoc = await fs.which(fullBinaryName);\n    log.info(`Using '${fullBinaryName}' from '${binaryLoc}'`);\n    this.binaries[binaryName] = binaryLoc;\n    return binaryLoc;\n  } catch (e) {\n    throw new Error(`Could not find '${fullBinaryName}' in PATH. Please set the ANDROID_HOME ` +\n      `or ANDROID_SDK_ROOT environment variables to the correct Android SDK root directory path.`);\n  }\n};\n\n/**\n * @typedef {Object} ConnectedDevicesOptions\n * @property {?boolean} verbose - Whether to get long output, which includes extra properties in each device.\n * Akin to running `adb devices -l`.\n */\n\n/**\n * @typedef {Object} Device\n * @property {string} udid - The device udid.\n * @property {string} state - Current device state, as it is visible in\n *                            _adb devices -l_ output.\n */\n\n/**\n * @typedef {Device} VerboseDevice Additional properties returned when `verbose` is true.\n * @property {string} product - The product codename of the device, such as \"razor\".\n * @property {string} model - The model name of the device, such as \"Nexus_7\".\n * @property {string} device - The device codename, such as \"flow\".\n * @property {?string} usb - Represents the USB port the device is connected to, such as \"1-1\".\n * @property {?string} transport_id - The Transport ID for the device, such as \"1\".\n */\n\n/**\n * Retrieve the list of devices visible to adb.\n *\n * @param {?ConnectedDevicesOptions} opts [{}] - Additional options mapping.\n * @return {Array.<Device>} The list of devices or an empty list if\n *                          no devices are connected.\n * @throws {Error} If there was an error while listing devices.\n */\nsystemCallMethods.getConnectedDevices = async function getConnectedDevices (opts = {}) {\n  log.debug('Getting connected devices');\n  const args = [...this.executable.defaultArgs, 'devices'];\n  if (opts.verbose) {\n    args.push('-l');\n  }\n\n  let stdout;\n  try {\n    ({stdout} = await exec(this.executable.path, args));\n  } catch (e) {\n    throw new Error(`Error while getting connected devices. Original error: ${e.message}`);\n  }\n  const listHeader = 'List of devices';\n  // expecting adb devices to return output as\n  // List of devices attached\n  // emulator-5554\tdevice\n  const startingIndex = stdout.indexOf(listHeader);\n  if (startingIndex < 0) {\n    throw new Error(`Unexpected output while trying to get devices: ${stdout}`);\n  }\n  // slicing output we care about\n  stdout = stdout.slice(startingIndex);\n  let excludedLines = [listHeader, 'adb server', '* daemon'];\n  if (!this.allowOfflineDevices) {\n    excludedLines.push('offline');\n  }\n  const devices = stdout.split('\\n')\n    .map(_.trim)\n    .filter((line) => line && !excludedLines.some((x) => line.includes(x)))\n    .map((line) => {\n      // state is \"device\", afaic\n      const [udid, state, ...description] = line.split(/\\s+/);\n      const device = {udid, state};\n      if (opts.verbose) {\n        for (const entry of description) {\n          if (entry.includes(':')) {\n            // each entry looks like key:value\n            const [key, value] = entry.split(':');\n            device[key] = value;\n          }\n        }\n      }\n      return device;\n    });\n  if (_.isEmpty(devices)) {\n    log.debug('No connected devices have been detected');\n  } else {\n    log.debug(`Connected devices: ${JSON.stringify(devices)}`);\n  }\n  return devices;\n};\n\n/**\n * Retrieve the list of devices visible to adb within the given timeout.\n *\n * @param {number} timeoutMs - The maximum number of milliseconds to get at least\n *                             one list item.\n * @return {Array.<Device>} The list of connected devices.\n * @throws {Error} If no connected devices can be detected within the given timeout.\n */\nsystemCallMethods.getDevicesWithRetry = async function getDevicesWithRetry (timeoutMs = 20000) {\n  const timer = new timing.Timer().start();\n  log.debug('Trying to find a connected android device');\n  const getDevices = async () => {\n    if (timer.getDuration().asMilliSeconds > timeoutMs) {\n      throw new Error(`Could not find a connected Android device in ${timer.getDuration().asMilliSeconds.toFixed(0)}ms.`);\n    }\n    try {\n      const devices = await this.getConnectedDevices();\n      if (devices.length > 0) {\n        return devices;\n      }\n    } catch (ign) {}\n\n    log.debug('Could not find online devices');\n    try {\n      await this.reconnect();\n    } catch (ign) {\n      await this.restartAdb();\n    }\n    // cool down\n    await sleep(200);\n    return await getDevices();\n  };\n  return await getDevices();\n};\n\n/**\n * Kick current connection from host/device side and make it reconnect\n *\n * @param {?string} target [offline] One of possible targets to reconnect:\n * offline, device or null\n * Providing `null` will cause reconnection to happen from the host side.\n *\n * @throws {Error} If either ADB version is too old and does not support this\n * command or there was a failure during reconnect.\n */\nsystemCallMethods.reconnect = async function reconnect (target = 'offline') {\n  log.debug(`Reconnecting adb (target ${target})`);\n\n  const args = ['reconnect'];\n  if (target) {\n    args.push(target);\n  }\n  try {\n    await this.adbExec(args);\n  } catch (e) {\n    throw new Error(`Cannot reconnect adb. Original error: ${e.stderr || e.message}`);\n  }\n};\n\n/**\n * Restart adb server, unless _this.suppressKillServer_ property is true.\n */\nsystemCallMethods.restartAdb = async function restartAdb () {\n  if (this.suppressKillServer) {\n    log.debug(`Not restarting abd since 'suppressKillServer' is on`);\n    return;\n  }\n\n  log.debug('Restarting adb');\n  try {\n    await this.killServer();\n    await this.adbExec(['start-server']);\n  } catch (e) {\n    log.error(`Error killing ADB server, going to see if it's online anyway`);\n  }\n};\n\n/**\n * Kill adb server.\n */\nsystemCallMethods.killServer = async function killServer () {\n  log.debug(`Killing adb server on port '${this.adbPort}'`);\n  await this.adbExec(['kill-server'], {\n    exclusive: true,\n  });\n};\n\n/**\n * Reset Telnet authentication token.\n * @see {@link http://tools.android.com/recent/emulator2516releasenotes} for more details.\n *\n * @returns {boolean} If token reset was successful.\n */\nsystemCallMethods.resetTelnetAuthToken = _.memoize(async function resetTelnetAuthToken () {\n  // The methods is used to remove telnet auth token\n  //\n  const homeFolderPath = process.env[(process.platform === 'win32') ? 'USERPROFILE' : 'HOME'];\n  if (!homeFolderPath) {\n    log.warn(`Cannot find the path to user home folder. Ignoring resetting of emulator's telnet authentication token`);\n    return false;\n  }\n  const dstPath = path.resolve(homeFolderPath, '.emulator_console_auth_token');\n  log.debug(`Overriding ${dstPath} with an empty string to avoid telnet authentication for emulator commands`);\n  try {\n    await fs.writeFile(dstPath, '');\n  } catch (e) {\n    log.warn(`Error ${e.message} while resetting the content of ${dstPath}. Ignoring resetting of emulator's telnet authentication token`);\n    return false;\n  }\n  return true;\n});\n\n/**\n * Execute the given emulator command using _adb emu_ tool.\n *\n * @param {Array.<string>} cmd - The array of rest command line parameters.\n */\nsystemCallMethods.adbExecEmu = async function adbExecEmu (cmd) {\n  await this.verifyEmulatorConnected();\n  await this.resetTelnetAuthToken();\n  await this.adbExec(['emu', ...cmd]);\n};\n\nlet isExecLocked = false;\n\nsystemCallMethods.EXEC_OUTPUT_FORMAT = Object.freeze({\n  STDOUT: 'stdout',\n  FULL: 'full',\n});\n\n/**\n * @typedef {Object} ExecResult\n * @property {string} stdout The stdout received from exec\n * @property {string} stderr The stderr received from exec\n */\n\n/**\n * Execute the given adb command.\n *\n * @param {Array.<string>} cmd - The array of rest command line parameters\n *                      or a single string parameter.\n * @param {Object} opts - Additional options mapping. See\n *                        {@link https://github.com/appium/node-teen_process}\n *                        for more details.\n *                        You can also set the additional `exclusive` param\n *                        to `true` that assures no other parallel adb commands\n *                        are going to be executed while the current one is running\n *                        You can set the `outputFormat` param to `stdout` to receive just the stdout\n *                        output (default) or `full` to receive the stdout and stderr response from a\n *                        command with a zero exit code\n * @return {string|ExecResult} - Command's stdout or an object containing stdout and stderr.\n * @throws {Error} If the command returned non-zero exit code.\n */\nsystemCallMethods.adbExec = async function adbExec (cmd, opts = {}) {\n  if (!cmd) {\n    throw new Error('You need to pass in a command to adbExec()');\n  }\n\n  opts = _.cloneDeep(opts);\n  // setting default timeout for each command to prevent infinite wait.\n  opts.timeout = opts.timeout || this.adbExecTimeout || DEFAULT_ADB_EXEC_TIMEOUT;\n  opts.timeoutCapName = opts.timeoutCapName || 'adbExecTimeout'; // For error message\n\n  const {outputFormat = this.EXEC_OUTPUT_FORMAT.STDOUT} = opts;\n\n  cmd = _.isArray(cmd) ? cmd : [cmd];\n  let adbRetried = false;\n  const execFunc = async () => {\n    try {\n      const args = [...this.executable.defaultArgs, ...cmd];\n      log.debug(`Running '${this.executable.path} ` +\n        (args.find((arg) => /\\s+/.test(arg)) ? util.quote(args) : args.join(' ')) + `'`);\n      let {stdout, stderr} = await exec(this.executable.path, args, opts);\n      // sometimes ADB prints out weird stdout warnings that we don't want\n      // to include in any of the response data, so let's strip it out\n      stdout = stdout.replace(LINKER_WARNING_REGEXP, '').trim();\n      return outputFormat === this.EXEC_OUTPUT_FORMAT.FULL ? {stdout, stderr} : stdout;\n    } catch (e) {\n      const errText = `${e.message}, ${e.stdout}, ${e.stderr}`;\n      if (ADB_RETRY_ERROR_PATTERNS.some((p) => p.test(errText))) {\n        log.info(`Error sending command, reconnecting device and retrying: ${cmd}`);\n        await sleep(1000);\n        await this.getDevicesWithRetry();\n\n        // try again one time\n        if (adbRetried) {\n          adbRetried = true;\n          return await execFunc();\n        }\n      }\n\n      if (e.code === 0 && e.stdout) {\n        return e.stdout.replace(LINKER_WARNING_REGEXP, '').trim();\n      }\n\n      if (_.isNull(e.code)) {\n        e.message = `Error executing adbExec. Original error: '${e.message}'. ` +\n          `Try to increase the ${opts.timeout}ms adb execution timeout represented by '${opts.timeoutCapName}' capability`;\n      } else {\n        e.message = `Error executing adbExec. Original error: '${e.message}'; ` +\n          `Command output: ${e.stderr || e.stdout || '<empty>'}`;\n      }\n      throw e;\n    }\n  };\n\n  if (isExecLocked) {\n    log.debug('Waiting until the other exclusive ADB command is completed');\n    await waitForCondition(() => !isExecLocked, {\n      waitMs: Number.MAX_SAFE_INTEGER,\n      intervalMs: 10,\n    });\n    log.debug('Continuing with the current ADB command');\n  }\n  if (opts.exclusive) {\n    isExecLocked = true;\n  }\n  try {\n    return await execFunc();\n  } finally {\n    if (opts.exclusive) {\n      isExecLocked = false;\n    }\n  }\n};\n\n/**\n * @typedef {Object} ShellExecOptions\n * @property {?string} timeoutCapName [adbExecTimeout] - the name of the corresponding Appium's timeout capability\n * (used in the error messages).\n * @property {?number} timeout [adbExecTimeout] - command execution timeout.\n * @property {?boolean} privileged [falsy] - Whether to run the given command as root.\n * @property {?string} outputFormat [stdout] - Whether response should include full exec output or just stdout.\n *                                             Potential values are full or stdout.\n *\n * All other properties are the same as for `exec` call from {@link https://github.com/appium/node-teen_process}\n * module\n */\n\n/**\n * Execute the given command using _adb shell_ prefix.\n *\n * @param {!Array.<string>|string} cmd - The array of rest command line parameters or a single\n *                                      string parameter.\n * @param {?ShellExecOptions} opts [{}] - Additional options mapping.\n * @return {string} - Command's stdout.\n * @throws {Error} If the command returned non-zero exit code.\n */\nsystemCallMethods.shell = async function shell (cmd, opts = {}) {\n  const {\n    privileged,\n  } = opts;\n\n  const cmdArr = _.isArray(cmd) ? cmd : [cmd];\n  const fullCmd = ['shell'];\n  if (privileged) {\n    log.info(`'adb shell ${util.quote(cmdArr)}' requires root access`);\n    if (await this.isRoot()) {\n      log.info('The device already had root access');\n      fullCmd.push(...cmdArr);\n    } else {\n      fullCmd.push('su', 'root', util.quote(cmdArr));\n    }\n  } else {\n    fullCmd.push(...cmdArr);\n  }\n  return await this.adbExec(fullCmd, opts);\n};\n\nsystemCallMethods.createSubProcess = function createSubProcess (args = []) {\n  // add the default arguments\n  args = [...this.executable.defaultArgs, ...args];\n  log.debug(`Creating ADB subprocess with args: ${JSON.stringify(args)}`);\n  return new SubProcess(this.getAdbPath(), args);\n};\n\n/**\n * Retrieve the current adb port.\n * @todo can probably deprecate this now that the logic is just to read this.adbPort\n * @return {number} The current adb port number.\n */\nsystemCallMethods.getAdbServerPort = function getAdbServerPort () {\n  return this.adbPort;\n};\n\n/**\n * Retrieve the current emulator port from _adb devives_ output.\n *\n * @return {number} The current emulator port.\n * @throws {Error} If there are no connected devices.\n */\nsystemCallMethods.getEmulatorPort = async function getEmulatorPort () {\n  log.debug('Getting running emulator port');\n  if (this.emulatorPort !== null) {\n    return this.emulatorPort;\n  }\n  try {\n    let devices = await this.getConnectedDevices();\n    let port = this.getPortFromEmulatorString(devices[0].udid);\n    if (port) {\n      return port;\n    } else {\n      throw new Error(`Emulator port not found`);\n    }\n  } catch (e) {\n    throw new Error(`No devices connected. Original error: ${e.message}`);\n  }\n};\n\n/**\n * Retrieve the current emulator port by parsing emulator name string.\n *\n * @param {string} emStr - Emulator name string.\n * @return {number|boolean} Either the current emulator port or\n *                          _false_ if port number cannot be parsed.\n */\nsystemCallMethods.getPortFromEmulatorString = function getPortFromEmulatorString (emStr) {\n  let portPattern = /emulator-(\\d+)/;\n  if (portPattern.test(emStr)) {\n    return parseInt(portPattern.exec(emStr)[1], 10);\n  }\n  return false;\n};\n\n/**\n * Retrieve the list of currently connected emulators.\n *\n * @param {?ConnectedDevicesOptions} opts [{}] - Additional options mapping.\n * @return {Array.<Device>} The list of connected devices.\n */\nsystemCallMethods.getConnectedEmulators = async function getConnectedEmulators (opts = {}) {\n  log.debug('Getting connected emulators');\n  try {\n    let devices = await this.getConnectedDevices(opts);\n    let emulators = [];\n    for (let device of devices) {\n      let port = this.getPortFromEmulatorString(device.udid);\n      if (port) {\n        device.port = port;\n        emulators.push(device);\n      }\n    }\n    log.debug(`${util.pluralize('emulator', emulators.length, true)} connected`);\n    return emulators;\n  } catch (e) {\n    throw new Error(`Error getting emulators. Original error: ${e.message}`);\n  }\n};\n\n/**\n * Set _emulatorPort_ property of the current class.\n *\n * @param {number} emPort - The emulator port to be set.\n */\nsystemCallMethods.setEmulatorPort = function setEmulatorPort (emPort) {\n  this.emulatorPort = emPort;\n};\n\n/**\n * Set the identifier of the current device (_this.curDeviceId_).\n *\n * @param {string} - The device identifier.\n */\nsystemCallMethods.setDeviceId = function setDeviceId (deviceId) {\n  log.debug(`Setting device id to ${deviceId}`);\n  this.curDeviceId = deviceId;\n  let argsHasDevice = this.executable.defaultArgs.indexOf('-s');\n  if (argsHasDevice !== -1) {\n    // remove the old device id from the arguments\n    this.executable.defaultArgs.splice(argsHasDevice, 2);\n  }\n  this.executable.defaultArgs.push('-s', deviceId);\n};\n\n/**\n * Set the the current device object.\n *\n * @param {Device} deviceObj - The device object to be set.\n */\nsystemCallMethods.setDevice = function setDevice (deviceObj) {\n  let deviceId = deviceObj.udid;\n  let emPort = this.getPortFromEmulatorString(deviceId);\n  this.setEmulatorPort(emPort);\n  this.setDeviceId(deviceId);\n};\n\n/**\n * Get the object for the currently running emulator.\n * !!! This method has a side effect - it implicitly changes the\n * `deviceId` (only if AVD with a matching name is found)\n * and `emulatorPort` instance properties.\n *\n * @param {string} avdName - Emulator name.\n * @return {?Device} Currently running emulator or _null_.\n */\nsystemCallMethods.getRunningAVD = async function getRunningAVD (avdName) {\n  log.debug(`Trying to find '${avdName}' emulator`);\n  try {\n    const emulators = await this.getConnectedEmulators();\n    for (const emulator of emulators) {\n      this.setEmulatorPort(emulator.port);\n      const runningAVDName = await this.execEmuConsoleCommand(['avd', 'name'], {\n        port: emulator.port,\n        execTimeout: 5000,\n        connTimeout: 1000,\n      });\n      if (_.toLower(avdName) === _.toLower(runningAVDName.trim())) {\n        log.debug(`Found emulator '${avdName}' on port ${emulator.port}`);\n        this.setDeviceId(emulator.udid);\n        return emulator;\n      }\n    }\n    log.debug(`Emulator '${avdName}' not running`);\n    return null;\n  } catch (e) {\n    throw new Error(`Error getting AVD. Original error: ${e.message}`);\n  }\n};\n\n/**\n * Get the object for the currently running emulator.\n *\n * @param {string} avdName - Emulator name.\n * @param {number} timeoutMs [20000] - The maximum number of milliseconds\n *                                     to wait until at least one running AVD object\n *                                     is detected.\n * @return {?Device} Currently running emulator or _null_.\n * @throws {Error} If no device has been detected within the timeout.\n */\nsystemCallMethods.getRunningAVDWithRetry = async function getRunningAVDWithRetry (avdName, timeoutMs = 20000) {\n  try {\n    return await waitForCondition(async () => {\n      try {\n        return await this.getRunningAVD(avdName.replace('@', ''));\n      } catch (e) {\n        log.debug(e.message);\n        return false;\n      }\n    }, {\n      waitMs: timeoutMs,\n      intervalMs: 1000,\n    });\n  } catch (e) {\n    throw new Error(`Error getting AVD with retry. Original error: ${e.message}`);\n  }\n};\n\n/**\n * Shutdown all running emulators by killing their processes.\n *\n * @throws {Error} If killing tool returned non-zero return code.\n */\nsystemCallMethods.killAllEmulators = async function killAllEmulators () {\n  let cmd, args;\n  if (system.isWindows()) {\n    cmd = 'TASKKILL';\n    args = ['TASKKILL', '/IM', 'emulator.exe'];\n  } else {\n    cmd = '/usr/bin/killall';\n    args = ['-m', 'emulator*'];\n  }\n  try {\n    await exec(cmd, args);\n  } catch (e) {\n    throw new Error(`Error killing emulators. Original error: ${e.message}`);\n  }\n};\n\n/**\n * Kill emulator with the given name. No error\n * is thrown is given avd does not exist/is not running.\n *\n * @param {?string} avdName - The name of the emulator to be killed. If empty,\n *                            the current emulator will be killed.\n * @param {?number} timeout [60000] - The amount of time to wait before throwing\n *                                    an exception about unsuccessful killing\n * @return {boolean} - True if the emulator was killed, false otherwise.\n * @throws {Error} if there was a failure by killing the emulator\n */\nsystemCallMethods.killEmulator = async function killEmulator (avdName = null, timeout = 60000) {\n  if (util.hasValue(avdName)) {\n    log.debug(`Killing avd '${avdName}'`);\n    const device = await this.getRunningAVD(avdName);\n    if (!device) {\n      log.info(`No avd with name '${avdName}' running. Skipping kill step.`);\n      return false;\n    }\n  } else {\n    // killing the current avd\n    log.debug(`Killing avd with id '${this.curDeviceId}'`);\n    if (!await this.isEmulatorConnected()) {\n      log.debug(`Emulator with id '${this.curDeviceId}' not connected. Skipping kill step`);\n      return false;\n    }\n  }\n  await this.adbExec(['emu', 'kill']);\n  log.debug(`Waiting up to ${timeout}ms until the emulator '${avdName ? avdName : this.curDeviceId}' is killed`);\n  try {\n    await waitForCondition(async () => {\n      try {\n        return util.hasValue(avdName)\n          ? !await this.getRunningAVD(avdName)\n          : !await this.isEmulatorConnected();\n      } catch (ign) {}\n      return false;\n    }, {\n      waitMs: timeout,\n      intervalMs: 2000,\n    });\n  } catch (e) {\n    throw new Error(`The emulator '${avdName ? avdName : this.curDeviceId}' is still running after being killed ${timeout}ms ago`);\n  }\n  log.info(`Successfully killed the '${avdName ? avdName : this.curDeviceId}' emulator`);\n  return true;\n};\n\n/**\n * @typedef {Object} AvdLaunchOptions\n * @property {string|Array<string>} args Additional emulator command line arguments\n * @property {Object} env Additional emulator environment variables\n * @property {string} language Emulator system language\n * @property {string} country Emulator system country\n * @property {number} launchTimeout [60000] Emulator startup timeout in milliseconds\n * @property {number} readyTimeout [60000] The maximum period of time to wait until Emulator\n * is ready for usage in milliseconds\n * @property {number} retryTimes [1] The maximum number of startup retries\n */\n\n/**\n * Start an emulator with given parameters and wait until it is fully started.\n *\n * @param {string} avdName - The name of an existing emulator.\n * @param {?AvdLaunchOptions} opts\n * @returns {SubProcess} Emulator subprocess instance\n * @throws {Error} If the emulator fails to start within the given timeout.\n */\nsystemCallMethods.launchAVD = async function launchAVD (avdName, opts = {}) {\n  const {\n    args = [],\n    env = {},\n    language,\n    country,\n    launchTimeout = 60000,\n    readyTimeout = 60000,\n    retryTimes = 1,\n  } = opts;\n  log.debug(`Launching Emulator with AVD ${avdName}, launchTimeout ` +\n            `${launchTimeout}ms and readyTimeout ${readyTimeout}ms`);\n  const emulatorBinaryPath = await this.getSdkBinaryPath('emulator');\n  if (avdName[0] === '@') {\n    avdName = avdName.substr(1);\n  }\n  await this.checkAvdExist(avdName);\n\n  const launchArgs = ['-avd', avdName];\n  launchArgs.push(...(toAvdLocaleArgs(language, country)));\n\n  let isDelayAdbFeatureEnabled = false;\n  if (this.allowDelayAdb) {\n    const {revision} = await this.getEmuVersionInfo();\n    if (revision && util.compareVersions(revision, '>=', '29.0.7')) {\n      // https://androidstudio.googleblog.com/2019/05/emulator-2907-canary.html\n      try {\n        const {target} = await this.getEmuImageProperties(avdName);\n        const apiMatch = /\\d+/.exec(target);\n        // https://issuetracker.google.com/issues/142533355\n        if (apiMatch && parseInt(apiMatch[0], 10) >= MIN_DELAY_ADB_API_LEVEL) {\n          launchArgs.push('-delay-adb');\n          isDelayAdbFeatureEnabled = true;\n        } else {\n          throw new Error(`The actual image API version is below ${MIN_DELAY_ADB_API_LEVEL}`);\n        }\n      } catch (e) {\n        log.info(`The -delay-adb emulator startup detection feature will not be enabled. ` +\n          `Original error: ${e.message}`);\n      }\n    }\n  } else {\n    log.info('The -delay-adb emulator startup detection feature has been explicitly disabled');\n  }\n\n  if (!_.isEmpty(args)) {\n    launchArgs.push(...(_.isArray(args) ? args : util.shellParse(`${args}`)));\n  }\n\n  log.debug(`Running '${emulatorBinaryPath}' with args: ${util.quote(launchArgs)}`);\n  if (!_.isEmpty(env)) {\n    log.debug(`Customized emulator environment: ${JSON.stringify(env)}`);\n  }\n  const proc = new SubProcess(emulatorBinaryPath, launchArgs, {\n    env: Object.assign({}, process.env, env),\n  });\n  await proc.start(0);\n  proc.on('output', (stdout, stderr) => {\n    for (let line of (stdout || stderr || '').split('\\n').filter(Boolean)) {\n      log.info(`[AVD OUTPUT] ${line}`);\n    }\n  });\n  proc.on('die', (code, signal) => {\n    log.warn(`Emulator avd ${avdName} exited with code ${code}${signal ? `, signal ${signal}` : ''}`);\n  });\n  await retry(retryTimes, async () => await this.getRunningAVDWithRetry(avdName, launchTimeout));\n  // At this point we have deviceId already assigned\n  const timer = new timing.Timer().start();\n  if (isDelayAdbFeatureEnabled) {\n    try {\n      await this.adbExec(['wait-for-device'], {timeout: readyTimeout});\n    } catch (e) {\n      throw new Error(`'${avdName}' Emulator has failed to boot: ${e.stderr || e.message}`);\n    }\n  }\n  await this.waitForEmulatorReady(readyTimeout - timer.getDuration().asMilliSeconds);\n  return proc;\n};\n\n/**\n * @typedef {Object} BinaryVersion\n * @property {SemVer} version - The ADB binary version number\n * @property {number} build - The ADB binary build number\n */\n\n/**\n * @typedef {Object} BridgeVersion\n * @property {SemVer} version - The Android Debug Bridge version number\n */\n\n/**\n * @typedef {Object} Version\n * @property {?BinaryVersion} binary This version number might not be\n * be present for older ADB releases.\n * @property {BridgeVersion} bridge\n */\n\n/**\n * Get the adb version. The result of this method is cached.\n *\n * @return {Version}\n * @throws {Error} If it is not possible to parse adb binary version.\n */\nsystemCallMethods.getVersion = _.memoize(async function getVersion () {\n  let stdout;\n  try {\n    stdout = await this.adbExec('version');\n  } catch (e) {\n    throw new Error(`Error getting adb version: ${e.stderr || e.message}`);\n  }\n\n  const result = {};\n  const binaryVersionMatch = BINARY_VERSION_PATTERN.exec(stdout);\n  if (binaryVersionMatch) {\n    result.binary = {\n      version: semver.coerce(binaryVersionMatch[1]),\n      build: parseInt(binaryVersionMatch[2], 10),\n    };\n  }\n  const bridgeVersionMatch = BRIDGE_VERSION_PATTERN.exec(stdout);\n  if (bridgeVersionMatch) {\n    result.bridge = {\n      version: semver.coerce(bridgeVersionMatch[1]),\n    };\n  }\n  return result;\n});\n\n/**\n * Check if the current emulator is ready to accept further commands (booting completed).\n *\n * @param {number} timeoutMs [20000] - The maximum number of milliseconds to wait.\n * @throws {Error} If the emulator is not ready within the given timeout.\n */\nsystemCallMethods.waitForEmulatorReady = async function waitForEmulatorReady (timeoutMs = 20000) {\n  const requiredServicesRe = REQUIRED_SERVICES.map((name) => new RegExp(`\\\\b${name}:`));\n  let services;\n  try {\n    await waitForCondition(async () => {\n      try {\n        services = await this.shell(['service', 'list']);\n        return requiredServicesRe.every((pattern) => pattern.test(services));\n      } catch (err) {\n        log.debug(`Waiting for emulator startup. Intermediate error: ${err.message}`);\n        return false;\n      }\n    }, {\n      waitMs: timeoutMs,\n      intervalMs: 3000,\n    });\n  } catch (e) {\n    if (services) {\n      log.debug(`Recently listed services:\\n${services}`);\n    }\n    const missingServices = _.zip(REQUIRED_SERVICES, requiredServicesRe)\n      .filter(([, pattern]) => !pattern.test(services))\n      .map(([name]) => name);\n    throw new Error(`Emulator is not ready within ${timeoutMs}ms ` +\n      `(${missingServices} service${missingServices.length === 1 ? ' is' : 's are'} not running)`);\n  }\n};\n\n/**\n * Check if the current device is ready to accept further commands (booting completed).\n *\n * @param {number} appDeviceReadyTimeout [30] - The maximum number of seconds to wait.\n * @throws {Error} If the device is not ready within the given timeout.\n */\nsystemCallMethods.waitForDevice = async function waitForDevice (appDeviceReadyTimeout = 30) {\n  this.appDeviceReadyTimeout = appDeviceReadyTimeout;\n  const retries = 3;\n  const timeout = parseInt(this.appDeviceReadyTimeout, 10) * 1000 / retries;\n  await retry(retries, async () => {\n    try {\n      await this.adbExec('wait-for-device', {timeout});\n      await this.ping();\n    } catch (e) {\n      try {\n        await this.reconnect();\n      } catch (ign) {\n        await this.restartAdb();\n      }\n      await this.getConnectedDevices();\n      throw new Error(`Error waiting for the device to be available. Original error: '${e.message}'`);\n    }\n  });\n};\n\n/**\n * Reboot the current device and wait until it is completed.\n *\n * @param {number} retries [DEFAULT_ADB_REBOOT_RETRIES] - The maximum number of reboot retries.\n * @throws {Error} If the device failed to reboot and number of retries is exceeded.\n */\nsystemCallMethods.reboot = async function reboot (retries = DEFAULT_ADB_REBOOT_RETRIES) {\n  // Get root access so we can run the next shell commands which require root access\n  const { wasAlreadyRooted } = await this.root();\n  try {\n    // Stop and re-start the device\n    await this.shell(['stop']);\n    await B.delay(2000); // let the emu finish stopping;\n    await this.setDeviceProperty('sys.boot_completed', 0, {\n      privileged: false // no need to set privileged true because device already rooted\n    });\n    await this.shell(['start']);\n  } catch (e) {\n    const {message} = e;\n\n    // provide a helpful error message if the reason reboot failed was because ADB couldn't gain root access\n    if (message.includes('must be root')) {\n      throw new Error(`Could not reboot device. Rebooting requires root access and ` +\n        `attempt to get root access on device failed with error: '${message}'`);\n    }\n    throw e;\n  } finally {\n    // Return root state to what it was before\n    if (!wasAlreadyRooted) {\n      await this.unroot();\n    }\n  }\n  const timer = new timing.Timer().start();\n  await retryInterval(retries, 1000, async () => {\n    if ((await this.getDeviceProperty('sys.boot_completed')) === '1') {\n      return;\n    }\n    // we don't want the stack trace, so no log.errorAndThrow\n    const msg = `Reboot is not completed after ${timer.getDuration().asMilliSeconds.toFixed(0)}ms`;\n    log.debug(msg);\n    throw new Error(msg);\n  });\n};\n\n/**\n * @typedef {Object} rootResult\n * @property {boolean} isSuccessful True if the call to root/unroot was successful\n * @property {boolean} wasAlreadyRooted True if the device was already rooted\n */\n\n/**\n * Switch adb server root privileges.\n * @param {boolean} isElevated - Should we elevate to to root or unroot? (default true)\n * @return {rootResult}\n */\nsystemCallMethods.changeUserPrivileges = async function changeUserPrivileges (isElevated) {\n  const cmd = isElevated ? 'root' : 'unroot';\n\n  const retryIfOffline = async (cmdFunc) => {\n    try {\n      return await cmdFunc();\n    } catch (err) {\n      // Check the output of the stdErr to see if there's any clues that show that the device went offline\n      // and if it did go offline, restart ADB\n      if (['closed', 'device offline', 'timeout expired']\n          .some((x) => (err.stderr || '').toLowerCase().includes(x))) {\n        log.warn(`Attempt to ${cmd} caused ADB to think the device went offline`);\n        try {\n          await this.reconnect();\n        } catch (ign) {\n          await this.restartAdb();\n        }\n        return await cmdFunc();\n      } else {\n        throw err;\n      }\n    }\n  };\n\n  // If it's already rooted, our job is done. No need to root it again.\n  const isRoot = await retryIfOffline(async () => await this.isRoot());\n  if ((isRoot && isElevated) || (!isRoot && !isElevated)) {\n    return {isSuccessful: true, wasAlreadyRooted: isRoot};\n  }\n\n  let wasAlreadyRooted = isRoot;\n  try {\n    const {stdout} = await retryIfOffline(async () => await this.adbExec([cmd]));\n    log.debug(stdout);\n\n    // on real devices in some situations we get an error in the stdout\n    if (stdout) {\n      if (stdout.includes('adbd cannot run as root')) {\n        return {isSuccessful: false, wasAlreadyRooted};\n      }\n      // if the device was already rooted, return that in the result\n      if (stdout.includes('already running as root')) {\n        wasAlreadyRooted = true;\n      }\n    }\n    return {isSuccessful: true, wasAlreadyRooted};\n  } catch (err) {\n    const {stderr = '', message} = err;\n    log.warn(`Unable to ${cmd} adb daemon. Original error: '${message}'. Stderr: '${stderr}'. Continuing.`);\n    return {isSuccessful: false, wasAlreadyRooted};\n  }\n};\n\n/**\n * Switch adb server to root mode\n * @return {rootResult}\n */\nsystemCallMethods.root = async function root () {\n  return await this.changeUserPrivileges(true);\n};\n\n/**\n * Switch adb server to non-root mode.\n *\n * @return {rootResult}\n */\nsystemCallMethods.unroot = async function unroot () {\n  return await this.changeUserPrivileges(false);\n};\n\n/**\n * Checks whether the current user is root\n *\n * @return {boolean} True if the user is root\n * @throws {Error} if there was an error while identifying\n * the user.\n */\nsystemCallMethods.isRoot = async function isRoot () {\n  return (await this.shell(['whoami'])).trim() === 'root';\n};\n\n/**\n * Verify whether a remote path exists on the device under test.\n *\n * @param {string} remotePath - The remote path to verify.\n * @return {boolean} True if the given path exists on the device.\n */\nsystemCallMethods.fileExists = async function fileExists (remotePath) {\n  const passFlag = '__PASS__';\n  const checkCmd = `[ -e '${remotePath.replace(/'/g, `\\\\'`)}' ] && echo ${passFlag}`;\n  try {\n    return _.includes(await this.shell([checkCmd]), passFlag);\n  } catch (ign) {\n    return false;\n  }\n};\n\n/**\n * Get the output of _ls_ command on the device under test.\n *\n * @param {string} remotePath - The remote path (the first argument to the _ls_ command).\n * @param {Array.<String>} opts [[]] - Additional _ls_ options.\n * @return {Array.<String>} The _ls_ output as an array of split lines.\n *                          An empty array is returned of the given _remotePath_\n *                          does not exist.\n */\nsystemCallMethods.ls = async function ls (remotePath, opts = []) {\n  try {\n    let args = ['ls', ...opts, remotePath];\n    let stdout = await this.shell(args);\n    let lines = stdout.split('\\n');\n    return lines.map((l) => l.trim())\n      .filter(Boolean)\n      .filter((l) => l.indexOf('No such file') === -1);\n  } catch (err) {\n    if (err.message.indexOf('No such file or directory') === -1) {\n      throw err;\n    }\n    return [];\n  }\n};\n\n/**\n * Get the size of the particular file located on the device under test.\n *\n * @param {string} remotePath - The remote path to the file.\n * @return {number} File size in bytes.\n * @throws {Error} If there was an error while getting the size of the given file.\n */\nsystemCallMethods.fileSize = async function fileSize (remotePath) {\n  try {\n    const files = await this.ls(remotePath, ['-la']);\n    if (files.length !== 1) {\n      throw new Error(`Remote path is not a file`);\n    }\n    // https://regex101.com/r/fOs4P4/8\n    const match = /[rwxsStT\\-+]{10}[\\s\\d]*\\s[^\\s]+\\s+[^\\s]+\\s+(\\d+)/.exec(files[0]);\n    if (!match || _.isNaN(parseInt(match[1], 10))) {\n      throw new Error(`Unable to parse size from list output: '${files[0]}'`);\n    }\n    return parseInt(match[1], 10);\n  } catch (err) {\n    throw new Error(`Unable to get file size for '${remotePath}': ${err.message}`);\n  }\n};\n\n/**\n * Installs the given certificate on a rooted real device or\n * an emulator. The emulator must be executed with `-writable-system`\n * command line option and adb daemon should be running in root\n * mode for this method to work properly. The method also requires\n * openssl tool to be available on the destination system.\n * Read https://github.com/appium/appium/issues/10964\n * for more details on this topic\n *\n * @param {Buffer|string} cert - base64-decoded content of the actual certificate\n * represented as a string or a buffer\n * @throws {Error} If openssl tool is not available on the destination system\n * or if there was an error while installing the certificate\n */\nsystemCallMethods.installMitmCertificate = async function installMitmCertificate (cert) {\n  const openSsl = await getOpenSslForOs();\n\n  if (!_.isBuffer(cert)) {\n    cert = Buffer.from(cert, 'base64');\n  }\n\n  const tmpRoot = await tempDir.openDir();\n  try {\n    const srcCert = path.resolve(tmpRoot, 'source.cer');\n    await fs.writeFile(srcCert, cert);\n    let {stdout} = await exec(openSsl, ['x509', '-noout', '-hash', '-in', srcCert]);\n    const certHash = stdout.trim();\n    log.debug(`Got certificate hash: ${certHash}`);\n    log.debug('Preparing certificate content');\n    ({stdout} = await exec(openSsl, ['x509', '-in', srcCert], {isBuffer: true}));\n    let dstCertContent = stdout;\n    ({stdout} = await exec(openSsl, ['x509',\n      '-in', srcCert,\n      '-text',\n      '-fingerprint',\n      '-noout'], {isBuffer: true}));\n    dstCertContent = Buffer.concat([dstCertContent, stdout]);\n    const dstCert = path.resolve(tmpRoot, `${certHash}.0`);\n    await fs.writeFile(dstCert, dstCertContent);\n    log.debug('Remounting /system in rw mode');\n    // Sometimes emulator reboot is still not fully finished on this stage, so retry\n    await retryInterval(5, 2000, async () => await this.adbExec(['remount']));\n    log.debug(`Uploading the generated certificate from '${dstCert}' to '${CERTS_ROOT}'`);\n    await this.push(dstCert, CERTS_ROOT);\n    log.debug('Remounting /system to confirm changes');\n    await this.adbExec(['remount']);\n  } catch (err) {\n    throw new Error(`Cannot inject the custom certificate. ` +\n                    `Is the certificate properly encoded into base64-string? ` +\n                    `Do you have root permissions on the device? ` +\n                    `Original error: ${err.message}`);\n  } finally {\n    await fs.rimraf(tmpRoot);\n  }\n};\n\n/**\n * Verifies if the given root certificate is already installed on the device.\n *\n * @param {Buffer|string} cert - base64-decoded content of the actual certificate\n * represented as a string or a buffer\n * @throws {Error} If openssl tool is not available on the destination system\n * or if there was an error while checking the certificate\n * @returns {boolean} true if the given certificate is already installed\n */\nsystemCallMethods.isMitmCertificateInstalled = async function isMitmCertificateInstalled (cert) {\n  const openSsl = await getOpenSslForOs();\n\n  if (!_.isBuffer(cert)) {\n    cert = Buffer.from(cert, 'base64');\n  }\n\n  const tmpRoot = await tempDir.openDir();\n  let certHash;\n  try {\n    const tmpCert = path.resolve(tmpRoot, 'source.cer');\n    await fs.writeFile(tmpCert, cert);\n    const {stdout} = await exec(openSsl, ['x509', '-noout', '-hash', '-in', tmpCert]);\n    certHash = stdout.trim();\n  } catch (err) {\n    throw new Error(`Cannot retrieve the certificate hash. ` +\n                    `Is the certificate properly encoded into base64-string? ` +\n                    `Original error: ${err.message}`);\n  } finally {\n    await fs.rimraf(tmpRoot);\n  }\n  const dstPath = path.posix.resolve(CERTS_ROOT, `${certHash}.0`);\n  log.debug(`Checking if the certificate is already installed at '${dstPath}'`);\n  return await this.fileExists(dstPath);\n};\n\nexport default systemCallMethods;\nexport { DEFAULT_ADB_EXEC_TIMEOUT, getAndroidBinaryPath };\n"],"mappings":"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"}